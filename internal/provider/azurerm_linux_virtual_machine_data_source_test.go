// Copyright (c) IBM Corporation
// SPDX-License-Identifier: Apache-2.0

// Code generated by provider-code-generator

package provider

import (
	"fmt"
	"net/http"
	"regexp"
	"strings"
	"testing"

	"github.com/hashicorp/terraform-plugin-testing/helper/resource"
)

const (
	azureLinuxVMConfig = `
	data "turbonomic_azurerm_linux_virtual_machine" "test" {
		entity_name  = "%s"
		default_size = "%s"
	}
	`
	azureLinuxConfigNoDefaultType = `
	data "turbonomic_azurerm_linux_virtual_machine" "test" {
		entity_name  = "%s"
	}
	`
	azureLinuxVMDataSourceRef = "data.turbonomic_azurerm_linux_virtual_machine.test"
	azureLinuxVMName          = "test-vm"
	azureLinuxVMCurrentType   = "standard_b1s"
	azureLinuxVMDefaultType   = "standard_d2s_v3"
	azureLinuxVMInvalidType   = "invalid@type#"
)

// Test for a valid entity
func TestAzurermLinuxVirtualMachineDataSourceWithValidEntity(t *testing.T) {
	mockServer := createLocalServer(t,
		loadTestFile(t, azureLinuxVMTestDataBaseDir, searchRespTestData),
		loadTestFile(t, azureLinuxVMTestDataBaseDir, validVmActionRespTestData),
		loadTestFile(t, entityTagTestDataBaseDir, entityTagsRespTestData),
		loadTestFile(t, entityTagTestDataBaseDir, entityTagRespTestData))
	defer mockServer.Close()

	providerConfig := fmt.Sprintf(config, strings.TrimPrefix(mockServer.URL, "https://"))

	for _, tc := range []struct {
		name                string
		testEntity          string
		expectedEntityName  string
		expectedDefaultType string
		expectedCurrentType string
		expectedNewType     string
	}{
		{
			name:                "Valid VM recommendation",
			testEntity:          azureLinuxVMName,
			expectedEntityName:  azureLinuxVMName,
			expectedDefaultType: azureLinuxVMDefaultType,
			expectedCurrentType: azureLinuxVMCurrentType,
			expectedNewType:     azureLinuxVMDefaultType,
		},
	} {
		t.Run(tc.name, func(t *testing.T) {
			resource.Test(t, resource.TestCase{
				ProtoV6ProviderFactories: testAccProtoV6ProviderFactories,
				Steps: []resource.TestStep{
					{
						Config: providerConfig + fmt.Sprintf(azureLinuxVMConfig, tc.testEntity, tc.expectedDefaultType),
						Check: resource.ComposeAggregateTestCheckFunc(
							resource.TestCheckResourceAttr(azureLinuxVMDataSourceRef, "entity_name", tc.expectedEntityName),
							resource.TestCheckResourceAttr(azureLinuxVMDataSourceRef, "entity_type", vmEntityType),
							resource.TestCheckResourceAttr(azureLinuxVMDataSourceRef, "current_size", tc.expectedCurrentType),
							resource.TestCheckResourceAttr(azureLinuxVMDataSourceRef, "default_size", tc.expectedDefaultType),
							resource.TestCheckResourceAttr(azureLinuxVMDataSourceRef, "new_size", tc.expectedNewType),
						),
					},
				},
			})
		})
	}
}

// Test for an invalid entity
func TestAzurermLinuxVirtualMachineDataSourceWithInvalidEntity(t *testing.T) {
	mockServer := createLocalServer(t, "[]", "", "", "")
	defer mockServer.Close()

	providerConfig := fmt.Sprintf(config, strings.TrimPrefix(mockServer.URL, "https://"))

	for _, tc := range []struct {
		name                string
		testEntity          string
		expectedEntityName  string
		expectedDefaultType string
		expectedNewType     string
	}{
		{
			name:                "Empty VM search",
			testEntity:          azureLinuxVMName,
			expectedEntityName:  azureLinuxVMName,
			expectedDefaultType: azureLinuxVMDefaultType,
			expectedNewType:     azureLinuxVMDefaultType,
		},
	} {
		t.Run(tc.name, func(t *testing.T) {
			resource.Test(t, resource.TestCase{
				ProtoV6ProviderFactories: testAccProtoV6ProviderFactories,
				Steps: []resource.TestStep{
					{
						Config: providerConfig + fmt.Sprintf(azureLinuxVMConfig, tc.testEntity, tc.expectedDefaultType),
						Check: resource.ComposeAggregateTestCheckFunc(
							resource.TestCheckResourceAttr(azureLinuxVMDataSourceRef, "entity_name", tc.expectedEntityName),
							resource.TestCheckNoResourceAttr(azureLinuxVMDataSourceRef, "entity_type"),
							resource.TestCheckNoResourceAttr(azureLinuxVMDataSourceRef, "current_size"),
							resource.TestCheckResourceAttr(azureLinuxVMDataSourceRef, "new_size", tc.expectedNewType),
							resource.TestCheckResourceAttr(azureLinuxVMDataSourceRef, "default_size", tc.expectedDefaultType),
						),
					},
				},
			})
		})
	}
}

// Test for an entity that has no actions
func TestAzurermLinuxVirtualMachineDataSourceWithNoAction(t *testing.T) {
	mockServer := createLocalServer(t,
		loadTestFile(t, azureLinuxVMTestDataBaseDir, searchRespTestData),
		loadTestFile(t, emptyActionRespTestData),
		loadTestFile(t, entityTagTestDataBaseDir, entityTagsRespTestData),
		loadTestFile(t, entityTagTestDataBaseDir, entityTagRespTestData))
	defer mockServer.Close()

	providerConfig := fmt.Sprintf(config, strings.TrimPrefix(mockServer.URL, "https://"))

	for _, tc := range []struct {
		name                string
		testEntity          string
		expectedEntityName  string
		expectedEntityType  string
		expectedCurrentType string
		expectedNewType     string
		expectedDefaultType string
	}{
		{
			name:                "Empty VM recommendation",
			testEntity:          azureLinuxVMName,
			expectedEntityName:  azureLinuxVMName,
			expectedDefaultType: azureLinuxVMDefaultType,
			expectedCurrentType: azureLinuxVMCurrentType,
			expectedNewType:     azureLinuxVMCurrentType,
		},
	} {
		t.Run(tc.name, func(t *testing.T) {
			resource.Test(t, resource.TestCase{
				ProtoV6ProviderFactories: testAccProtoV6ProviderFactories,
				Steps: []resource.TestStep{
					{
						Config: providerConfig + fmt.Sprintf(azureLinuxVMConfig, tc.testEntity, tc.expectedDefaultType),
						Check: resource.ComposeAggregateTestCheckFunc(
							resource.TestCheckResourceAttr(azureLinuxVMDataSourceRef, "entity_name", tc.expectedEntityName),
							resource.TestCheckResourceAttr(azureLinuxVMDataSourceRef, "entity_type", vmEntityType),
							resource.TestCheckResourceAttr(azureLinuxVMDataSourceRef, "current_size", tc.expectedCurrentType),
							resource.TestCheckResourceAttr(azureLinuxVMDataSourceRef, "default_size", tc.expectedDefaultType),
							resource.TestCheckResourceAttr(azureLinuxVMDataSourceRef, "new_size", tc.expectedNewType),
						),
					},
				},
			})
		})
	}
}

// Tests when default_size is not specified
func TestAzurermLinuxVirtualMachineDataSourceWithoutDefaultType(t *testing.T) {
	mockServer := createLocalServer(t,
		loadTestFile(t, azureLinuxVMTestDataBaseDir, searchRespTestData),
		loadTestFile(t, azureLinuxVMTestDataBaseDir, validVmActionRespTestData),
		loadTestFile(t, entityTagTestDataBaseDir, entityTagsRespTestData),
		loadTestFile(t, entityTagTestDataBaseDir, entityTagRespTestData))
	defer mockServer.Close()

	providerConfig := fmt.Sprintf(config, strings.TrimPrefix(mockServer.URL, "https://"))

	for _, tc := range []struct {
		name                string
		testEntity          string
		expectedEntityName  string
		expectedCurrentType string
		expectedNewType     string
	}{
		{
			name:                "default_size not specified",
			testEntity:          azureLinuxVMName,
			expectedEntityName:  azureLinuxVMName,
			expectedCurrentType: azureLinuxVMCurrentType,
			expectedNewType:     azureLinuxVMDefaultType,
		},
	} {
		t.Run(tc.name, func(t *testing.T) {
			resource.Test(t, resource.TestCase{
				ProtoV6ProviderFactories: testAccProtoV6ProviderFactories,
				Steps: []resource.TestStep{
					{
						Config: providerConfig + fmt.Sprintf(azureLinuxConfigNoDefaultType, tc.testEntity),
						Check: resource.ComposeAggregateTestCheckFunc(
							resource.TestCheckResourceAttr(azureLinuxVMDataSourceRef, "entity_name", tc.expectedEntityName),
							resource.TestCheckResourceAttr(azureLinuxVMDataSourceRef, "entity_type", vmEntityType),
							resource.TestCheckResourceAttr(azureLinuxVMDataSourceRef, "current_size", tc.expectedCurrentType),
							resource.TestCheckResourceAttr(azureLinuxVMDataSourceRef, "new_size", tc.expectedNewType),
						),
					},
				},
			})
		})
	}
}

// Tests error while retrieving entity tags
func TestAzurermLinuxVirtualMachineDataSourceGetEntityTagsError(t *testing.T) {
	mockServer := createLocalServer(t,
		loadTestFile(t, azureLinuxVMTestDataBaseDir, searchRespTestData),
		loadTestFile(t, azureLinuxVMTestDataBaseDir, validVmActionRespTestData),
		"",
		"")
	defer mockServer.Close()

	providerConfig := fmt.Sprintf(config, strings.TrimPrefix(mockServer.URL, "https://"))

	t.Run("Error while retrieving entity tags", func(t *testing.T) {
		resource.Test(t, resource.TestCase{
			ProtoV6ProviderFactories: testAccProtoV6ProviderFactories,
			Steps: []resource.TestStep{
				{
					Config:      providerConfig + fmt.Sprintf(azureLinuxVMConfig, azureLinuxVMName, azureLinuxVMDefaultType),
					ExpectError: regexp.MustCompile(`Unable to retrieve entity tags from Turbonomic`),
				},
			},
		})
	})
}

// Tests error while tagging an entity
func TestAzurermLinuxVirtualMachineDataSourceTagEntityError(t *testing.T) {
	mockServer := createLocalServer(t,
		loadTestFile(t, azureLinuxVMTestDataBaseDir, searchRespTestData),
		loadTestFile(t, azureLinuxVMTestDataBaseDir, validVmActionRespTestData),
		"[]",
		"")
	defer mockServer.Close()

	providerConfig := fmt.Sprintf(config, strings.TrimPrefix(mockServer.URL, "https://"))

	t.Run("Error while tagging an entity", func(t *testing.T) {
		resource.Test(t, resource.TestCase{
			ProtoV6ProviderFactories: testAccProtoV6ProviderFactories,
			Steps: []resource.TestStep{
				{
					Config:      providerConfig + fmt.Sprintf(azureLinuxVMConfig, azureLinuxVMName, azureLinuxVMDefaultType),
					ExpectError: regexp.MustCompile(`Unable to tag an entity in Turbonomic`),
				},
			},
		})
	})
}

// Tests no error while tagging already tagged entity with discovered "optimized by" tag value
func TestAzurermLinuxVirtualMachineDataSourceTagEntityAlreadyTaggedDiscovered(t *testing.T) {
	mockServer := createLocalServer(t,
		loadTestFile(t, azureLinuxVMTestDataBaseDir, searchRespTestData),
		loadTestFile(t, azureLinuxVMTestDataBaseDir, validVmActionRespTestData),
		`[{"key": "turbonomic_optimized_by","values": ["turbonomic-terraform-provider"]}]`,
		"")
	defer mockServer.Close()

	providerConfig := fmt.Sprintf(config, strings.TrimPrefix(mockServer.URL, "https://"))
	for _, tc := range []struct {
		name                string
		testEntity          string
		expectedEntityName  string
		expectedCurrentType string
		expectedNewType     string
		expectedDefaultType string
	}{
		{
			name:                "No error while tagging already tagged entity",
			testEntity:          azureLinuxVMName,
			expectedEntityName:  azureLinuxVMName,
			expectedCurrentType: azureLinuxVMCurrentType,
			expectedNewType:     azureLinuxVMDefaultType,
			expectedDefaultType: azureLinuxVMDefaultType,
		},
	} {
		t.Run(tc.name, func(t *testing.T) {
			resource.Test(t, resource.TestCase{
				ProtoV6ProviderFactories: testAccProtoV6ProviderFactories,
				Steps: []resource.TestStep{
					{
						Config: providerConfig + fmt.Sprintf(azureLinuxVMConfig, azureLinuxVMName, azureLinuxVMDefaultType),
						Check: resource.ComposeAggregateTestCheckFunc(
							resource.TestCheckResourceAttr(azureLinuxVMDataSourceRef, "entity_name", tc.expectedEntityName),
							resource.TestCheckResourceAttr(azureLinuxVMDataSourceRef, "entity_type", vmEntityType),
							resource.TestCheckResourceAttr(azureLinuxVMDataSourceRef, "current_size", tc.expectedCurrentType),
							resource.TestCheckResourceAttr(azureLinuxVMDataSourceRef, "new_size", tc.expectedNewType),
							resource.TestCheckResourceAttr(azureLinuxVMDataSourceRef, "default_size", tc.expectedDefaultType),
						),
					},
				},
			})
		})
	}
}

// Tests no error while tagging already tagged entity with not discovered "optimized by" tag value
func TestAzurermLinuxVirtualMachineDataSourceTagEntityAlreadyTaggedNotDiscovered(t *testing.T) {
	mockServer := createLocalServerWithResponse(t,
		loadTestFile(t, azureLinuxVMTestDataBaseDir, searchRespTestData),
		loadTestFile(t, azureLinuxVMTestDataBaseDir, validVmActionRespTestData),
		`[]`,
		Response{
			Message:    "Entity service RPC call failed to complete request: INVALID_ARGUMENT: Trying to insert a tag with a key that already exists: turbonomic_optimized_by",
			HttpStatus: http.StatusBadRequest})
	defer mockServer.Close()

	providerConfig := fmt.Sprintf(config, strings.TrimPrefix(mockServer.URL, "https://"))
	for _, tc := range []struct {
		name                string
		testEntity          string
		expectedEntityName  string
		expectedCurrentType string
		expectedNewType     string
		expectedDefaultType string
	}{
		{
			name:                "Error while tagging already tagged entity",
			testEntity:          azureLinuxVMName,
			expectedEntityName:  azureLinuxVMName,
			expectedCurrentType: azureLinuxVMCurrentType,
			expectedNewType:     azureLinuxVMDefaultType,
			expectedDefaultType: azureLinuxVMDefaultType,
		},
	} {
		t.Run(tc.name, func(t *testing.T) {
			resource.Test(t, resource.TestCase{
				ProtoV6ProviderFactories: testAccProtoV6ProviderFactories,
				Steps: []resource.TestStep{
					{
						Config: providerConfig + fmt.Sprintf(azureLinuxVMConfig, azureLinuxVMName, azureLinuxVMDefaultType),
						Check: resource.ComposeAggregateTestCheckFunc(
							resource.TestCheckResourceAttr(azureLinuxVMDataSourceRef, "entity_name", tc.expectedEntityName),
							resource.TestCheckResourceAttr(azureLinuxVMDataSourceRef, "entity_type", vmEntityType),
							resource.TestCheckResourceAttr(azureLinuxVMDataSourceRef, "current_size", tc.expectedCurrentType),
							resource.TestCheckResourceAttr(azureLinuxVMDataSourceRef, "new_size", tc.expectedNewType),
							resource.TestCheckResourceAttr(azureLinuxVMDataSourceRef, "default_size", tc.expectedDefaultType),
						),
					},
				},
			})
		})
	}
}

// Tests invalid characters in default_size field
func TestAzurermLinuxVirtualMachineDataSourceInvalidDefaultTypeCharacters(t *testing.T) {
	t.Run("Invalid characters in default_size", func(t *testing.T) {
		resource.Test(t, resource.TestCase{
			ProtoV6ProviderFactories: testAccProtoV6ProviderFactories,
			Steps: []resource.TestStep{
				{
					Config:      providerConfig + fmt.Sprintf(azureLinuxVMConfig, azureLinuxVMName, azureLinuxVMInvalidType),
					ExpectError: regexp.MustCompile(`Invalid Attribute Value Match`),
				},
			},
		})
	})
}
